package iters

import (
	"iter"
	"maps"
	"slices"

	"golang.org/x/exp/constraints"
)

// Generate an infinite iter.Seq where each element is generated by the provided supplier function.
// Due to the potential statefulness of the supplier, multiple operations towards the same iter.Seq might provide
// different results.
//
// This creates a lazy sequence. The supplier won't be called until it is requested for consumption by
// the transformation or aggregation functions.
//
// Caution! Unless you limit the lenght of the iter.Seq (e.g. using the Limit function), the aggregation
// functions over this iter.Seq might not terminate.
func Generate[T any](supplier func() T) iter.Seq[T] {
	return func(yield func(T) bool) {
		for yield(supplier()) {
		}
	}
}

// Iterate returns an infinite sequential ordered iter.Seq produced by iterative application of a function
// f to an initial element seed, producing a iter.Seq consisting of seed, f(seed), f(f(seed)), etc.
// The first element (position 0) in the iter.Seq will be the provided seed. For n > 0, the element at
// position n, will be the result of applying the function f to the element at position n - 1.
// Due to the stateful nature of the supplier, multiple operations towards the same iter.Seq might provide
// different results.
func Iterate[T any](seed T, f func(T) T) iter.Seq[T] {
	return func(yield func(T) bool) {
		lastElement := seed
		for yield(lastElement) {
			lastElement = f(lastElement)
		}
	}
}

// Concat creates a lazily concatenated iter.Seq whose elements are all the elements of the first iter.Seq
// followed by all the elements of the second iter.Seq.
func Concat[T any](a, b iter.Seq[T]) iter.Seq[T] {
	return func(yield func(T) bool) {
		for i := range a {
			if !yield(i) {
				return
			}
		}
		for i := range b {
			if !yield(i) {
				return
			}
		}
	}
}

// Empty returns an empty iter.Seq
func Empty[T any]() iter.Seq[T] {
	return func(_ func(T) bool) {}
}

// Keys returns an iter.Seq that iterates the keys (first/left items) of the source iter.Seq2
func Keys[K, V any](source iter.Seq2[K, V]) iter.Seq[K] {
	return func(yield func(K) bool) {
		for k := range source {
			if !yield(k) {
				return
			}
		}
	}
}

// Values returns an iter.Seq that iterates the values (second/right items) of the source iter.Seq2
func Values[K, V any](source iter.Seq2[K, V]) iter.Seq[V] {
	return func(yield func(V) bool) {
		for _, v := range source {
			if !yield(v) {
				return
			}
		}
	}
}

// Of returns an iter.Seq that iterates each of the passed arguments in order.
func Of[T any](a ...T) iter.Seq[T] {
	return slices.Values(a)
}

// OfRange returns an iter.Seq that iterates the integer numbers from
// the first argument (inclusive) to the second argument (exclusive).
func OfRange[T constraints.Integer](start, excludedEnd T) iter.Seq[T] {
	return func(yield func(T) bool) {
		for i := start; i < excludedEnd; i++ {
			if !yield(i) {
				return
			}
		}
	}
}

// OfChannel returns an iter.Seq that iterates over all values received from the provided channel.
// The iteration continues until the channel is closed.
// This means that aggregations over the returned iter.Seq might not terminate if the channel
// is inactive or never closed.
func OfChannel[T any](ch <-chan T) iter.Seq[T] {
	return func(yield func(T) bool) {
		for i := range ch {
			if !yield(i) {
				return
			}
		}
	}
}

// OfSlice returns an iter.Seq that iterates over all elements of the provided slice.
// It is just an alias for slices.Values.
func OfSlice[T any](sl []T) iter.Seq[T] {
	return slices.Values(sl)
}

// OfMap returns an iter.Seq2 that iterates over all key-value pairs of the provided map.
// It is just an alias for maps.All.
func OfMap[K comparable, V any](m map[K]V) iter.Seq2[K, V] {
	return maps.All(m)
}

// OfMapKeys returns an iter.Seq that iterates over all keys of the provided map.
// It is just an alias for maps.Keys.
func OfMapKeys[T comparable, K any](m map[T]K) iter.Seq[T] {
	return maps.Keys(m)
}

// OfMapValues returns an iter.Seq that iterates over all values of the provided map.
// It is just an alias for maps.Values.
func OfMapValues[T comparable, V any](m map[T]V) iter.Seq[V] {
	return maps.Values(m)
}

// Zip joins the input iter.Seq[K] and iter.Seq[V] into an iter.Seq2[K, V].
// The resulting iter.Seq2 will have the same length as the shorter of the two input iter.Seq.
func Zip[K, V any](keys iter.Seq[K], vals iter.Seq[V]) iter.Seq2[K, V] {
	return func(yield func(K, V) bool) {
		keyNext, keyStop := iter.Pull(keys)
		defer keyStop()
		valNext, valStop := iter.Pull(vals)
		defer valStop()

		for {
			k, kOk := keyNext()
			v, vOk := valNext()

			if !kOk || !vOk {
				return
			}

			if !yield(k, v) {
				return
			}
		}
	}
}
